#+TITLE: TPHmacs
#+AUTHOR: TPH Gang
#+STARTUP: overview

* Preface

  Hey! So in your =init.el= you just have one line! The line

  #+begin_src
(org-babel-load-file (concat user-emacs-directory "config.org"))
  #+end_src

  is very simple. To start with, =(concat user-emacs-directory "config.org")=
  concatenates "config.org" to your emacs directory. Although the [[file:~/github/emacs/README.org][README.org]] stated to
  copy and paste this into your =.emacs.d=, your =.emacs.d= doesn't have to be where your
  configuration is stored. There is a neat project called [[https://github.com/plexus/chemacs][chemacs]] which lets you run
  multiple emacs configurations once you set it up. This can be helpful when you're
  testing out new features or want to try other configurations.

  So, assuming you're using =.emacs.d=, we now have the string =~/.emacs.d/config.org=.
  =org-babel-load-file= does something particularly cool: it tangles emacs-lisp source
  blocks  =~/.emacs.d/config.org=. Referring to documentations:

  #+begin_quote
  (org-babel-load-file FILE &optional COMPILE)

  Load Emacs Lisp source code blocks in the Org FILE.
  This function exports the source code using ‘org-babel-tangle’
  and then loads the resulting file using ‘load-file’.  With
  optional prefix argument COMPILE, the tangled Emacs Lisp file is
  byte-compiled before it is loaded.
  #+end_quote

  To begin with, the definition mentions =load-file= which does what it sounds like: it
  loads a file. If we had written the emacs configuration into a file like =config.el=,
  we could have called =(load-file (concat user-emacs-directory "config.org")=. Or, we
  could have left the entire configuration in =init.el= at that point... The benefit of
  using an org file is that we get a /literate/ configuration. ~babel~ is an immensely
  powerful tool which is heavily integrated into org (which we'll discuss later).

  Backtracking to the idea of 'emacs-lisp source blocks' being 'tangled', essentially
  any blocks in the org file starting with =#+begin_src emacs-lisp= to =#+end_src= will
  be read into the compiled el file which gets loaded. Without specifying anything,
  emacs will automagically try to use the name of the org file for the el file
  (config.org will compile to config.el). This can be changed by modifying the file's
  properties, which is as simple as placing =#+property: header-args :tangle init.el=
  on top of the file. The snippet in the previous line tangles the file to =init.el=.

* Pre-Configuration

  This code should be executed first. It's general, but will make the rest of the configuration nicer since it's somewhat 'meta'.

** Initialization

   Add lexical binding support

   #+begin_src emacs-lisp
   ;; -*- lexical-binding: t -*-
   #+end_src

** Garbage Collection

   We don't need garbage collection during start up.

   #+begin_src emacs-lisp
   (eval-when-compile
     (setq-local gc-cons-threshold most-positive-fixnum)
     (setq-local gc-cons-percentage 0.6)
     (setq-local file-name-handler-alist nil))
   #+end_src

** Package Archives

   Special commands, should always be needed. Note the algorithm is a hotfix to a much larger [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34341][Emacs issue]].

   #+begin_src emacs-lisp
   (require 'package)
   (setq package-enable-at-startup nil)
   (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
   #+end_src

   Set up all the archive sources to pull from packages from.

   #+begin_src emacs-lisp
   (setq package-archives '(("melpa" . "http://melpa.milkbox.net/packages/")
                            ("gnu" . "http://elpa.gnu.org/packages/")
                            ("org" . "https://orgmode.org/elpa/")))

   (package-initialize)
   #+end_src

** Package Installers

   [[https://github.com/jwiegley/use-package][use-package]] configuration. Helps clean up rest of the configuration and speeds up startup by isolating packages.

   #+begin_src emacs-lisp
   (unless (package-installed-p 'use-package)
     (package-refresh-contents)
     (package-install 'use-package))

   (eval-when-compile
     (require 'use-package))

   ;; Yes, it's a bit meta...
   (use-package use-package
     :config
     (setq-default use-package-always-defer nil
                   use-package-always-demand t
                   use-package-always-ensure t
                   use-package-verbose t))

   (setq-default byte-compile-warnings nil)
   #+end_src

* Projects

  Projectile gives Emacs project management features, such as navigating files, finding occurences of a string, running build commands and more.
  It detects project folders through version control (git, svn, ...) and you can optionally give a default project folder path within the config.

  #+begin_src emacs-lisp
  (use-package projectile
    :custom
    (projectile-project-search-path '("~/Projects/"))
    (projectile-enable-caching t)
    (projectile-require-project-root t)
    (projectile-sort-order 'access-time)
    ;; Useful for any CMake-based project, and using `ccls` with C/C++
    (projectile-project-root-files-top-down-recurring
     (append
      '("compile_commands.json" ".ccls")
      projectile-project-root-files-top-down-recurring))
    (projectile-globally-ignored-directories
     (append
      '("build" "CMakeFiles" ".ccls-cache")
      projectile-globally-ignored-directories))
    (projectile-globally-ignored-files
     (append
      '("cmake_install.cmake")
      projectile-globally-ignored-files))
    :init
    (projectile-mode))
  #+end_src

  #+begin_src emacs-lisp
  (use-package magit)
  #+end_src

* Key bindings

  #+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (use-package yasnippet)
  (use-package hydra)

  (use-package flycheck)
  #+END_SRC

* Language servers

  #+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :hook ((c-mode c++mode python-mode sh-mode) . lsp)
    :custom
    (lsp-auto-guess-root t)
    (lsp-log-io t)
    (lsp-prefer-flymake nil))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-delay 3.0)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-flycheck-enable t)
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-symbol t))

  (use-package company
    :hook (after-init . global-company-mode)
    :custom
    (company-tooltip-align-annotations t))

  (use-package company-lsp
    :after (company lsp-mode)
    ;; TODO
    ;; :bind (:map lsp-mode-map ("C-." . company-lsp))
    :custom
    (company-lsp-cache-candidates t))
    ;; :config
    ;; (add-to-list 'company-backends #'company-lsp))

  (use-package dap-mode
    :after lsp-mode
    :config
    (dap-mode t)
    (dap-ui-mode t))

  ;; (use-package treemacs
  ;;   :bind (:map global-map
  ;;               ("C-x t t" . treemacs)
  ;;               ("C-x t 1" . treemacs-select-window))
  ;;   :custom
  ;;   (treemacs-resize-icons 15))

  ;; (use-package lsp-treemacs
  ;;   :init (lsp-treemacs-sync-mode 1)

  ;;   :bind (:map java-mode-map
  ;;               ("C-x e l" . lsp-treemacs-errors-list)
  ;;               ("C-x s l" . lsp-treemacs-symbols)))

  #+END_SRC

* Languages

** HTML / CSS / HTML Templates

  #+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :hook ((css-mode php-mode sgml-mode rjsx-mode web-mode) . emmet-mode))
  #+END_SRC

** JavaScript / TypeScript

  These two are probably the hardest configuration to get properly solely because of "standards".

  #+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :hook
    (typescript-mode . lsp)
    :mode (("\\.ts\\'" . typescript-mode)
           ("\\.tsx\\'" . typescript-mode)))
  #+END_SRC

  Use Node modules is present. Especially helpful for versions of tools and for stuff like prettier.

  #+BEGIN_SRC emacs-lisp
  (use-package add-node-modules-path
    :hook
    ((web-mode . add-node-modules-path)
     (rjsx-mode . add-node-modules-path)))
  #+END_SRC

  Actually add prettier (which will read from =.prettierrc= if it exists now). Note you’ll have to install it using =npm install -g prettier=.

  #+BEGIN_SRC emacs-lisp
  (use-package prettier-js
    :hook
    ((js-mode . prettier-js-mode)
     (typescript-mode . prettier-js-mode)
     (rjsx-mode . prettier-js-mode)))
  #+END_SRC

  [[https://github.com/ananthakumaran/tide][TypeScript Interactive Development Environment for Emacs]]

  #+BEGIN_SRC emacs-lisp
  ;; TODO
  (defun setup-tide-mode ()
    "Setup tide for javascript."
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1))

  (use-package tide
    :after
    (typescript-mode company flycheck)
    :hook
    ((typescript-mode . tide-setup)
     (typescript-mode . tide-hl-identifier-mode)
     (before-save . tide-format-before-save))
    :config
    (flycheck-add-next-checker 'typescript-tide 'javascript-eslint)
    (flycheck-add-next-checker 'tsx-tide 'javascript-eslint))
  #+END_SRC

  Modern React, note it’s generally a bad idea to bind this to ts or tsx since TypeScript uses =:= for types, which rjsx doesn’t seem to interpret well (it would be very nice if this was fixed!):

  #+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :mode
    (("\\.js\\'"   . rjsx-mode)
     ("\\.jsx\\'"  . rjsx-mode)
     ("\\.json\\'" . javascript-mode))
    :magic ("/\\*\\* @jsx React\\.DOM \\*/" "^import React")
    :init
    (setq-default rjsx-basic-offset 2)
    (setq-default rjsx-global-externs '("module" "require" "assert" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON")))

  (use-package react-snippets
    :after yasnippet)
  #+END_SRC

  For vue specifics as well:

  #+BEGIN_SRC emacs-lisp
  (use-package vue-html-mode)

  (use-package vue-mode
    :defer t
    :mode
    (("\\.vue\\'"  . vue-mode)))
  #+END_SRC

** Java

  #+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :after lsp-mode
    :hook (java-mode . lsp))
  ;; TODO
  ;; (use-package dap-java
  ;;   :after (lsp-java dap-mode))
  #+END_SRC

** Python

** PHP

** C / C++

  These are available as core modes, no install required. Defaults are good but things such as brace and comment style are configurable.

  #+BEGIN_SRC emacs-lisp
  (setq c-basic-offset 4)
  (setq c-default-style
        '((java-mode . "java")
          (awk-mode . "awk")
          ;; default is "gnu"
          (other . "k&r")))
  (setq c-doc-comment-style
        '((c-mode . javadoc)
          (java-mode . javadoc)
          (pike-mode . autodoc)))
  #+END_SRC

  CMake is a common enough build tool that =cmake-mode= is a necessity.

  #+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
    :mode
    (("CMakeLists\\.txt\\'" . cmake-mode)
     ("CMakeCache\\.txt\\'" . cmake-mode)
     ("\\.cmake\\'" . cmake-mode))
    :custom
    (cmake-tab-width 4))
  #+END_SRC

  The language server interface that automatically comes with =lsp-mode= is for [[https://clang.llvm.org/extra/clangd/Installation.html][=clangd=]]. It works well for projects that are millions of lines in size and requires no configuration other than hooks. [[https://github.com/MaskRay/ccls][=ccls=]] is also available, which supports more language server features than =clangd= like overlays and semantic highlighting (see =config/c-and-cpp.org=).

  Both LSP implementations benefit from having =compile_commands.json= in the Projectile-discovered project root, which is created by passing =-DCMAKE_EXPORT_COMPILE_COMMANDS=1= to =cmake=.

** Rust

  There are two available modes:
  - [[https://github.com/rust-lang/rust-mode][rust-mode]]
  - [[https://github.com/brotzeit/rustic][rustic]]

  Of these, rust-mode is minimal, with just syntax highlighting, hooks to rustfmt for formatting buffers, hooks to =cargo build/run/test/clippy=, and some automatic integration with ={lsp,eglot}-mode= with using =rls= as the backend (=rustup component add rls=). Rustic is more full-featured, with all the features of rust-mode available, plus better cargo command naming and output, rustfix integration, and automatic flymake or flycheck integration with clippy. Using rust-analyzer as the language server backend is also possible (=rustup component add rust-analysis=).

  For example, here is how to run `cargo test` in each mode:
  - =rust-mode=: =M-x rust-test=
  - =rustic=: =M-x rustic-cargo-test=

  A sample =rustic= setup is

  #+BEGIN_SRC emacs-lisp
  (use-package rustic
    :custom
    (rustic-format-on-save t)
    (rustic-indent-method-chain t)
    ;; The default is 'rls
    (rustic-lsp-server 'rust-analyzer))
  #+END_SRC

** Clojure

  =clojure-mode= brings us basic functionalities like syntax highlighting, formatting and refactoring.

  #+BEGIN_SRC emacs-lisp
  (use-package clojure-mode)
  #+END_SRC

  We want more advanced features, which we will get through [[https://cider.mx/][CIDER]], a minor mode that adds functionalities to Emacs for editing and developing Clojure applications. CIDER is a REPL-based environment for Clojure, adding code completion, debugging, testing, documentation lookup, project configuration and more. It is a huge package, and you'll want to read the documentations and experiment on your own.

  When it is installed, you can go to your Clojure buffer and run the command =M-x cider-jack-in= to start a REPL and be able to use CIDER’s features.

  #+BEGIN_SRC emacs-lisp
  (use-package cider
    :custom
    (cider-print-fn 'fipp)
    (cider-repl-pop-to-buffer-on-connect nil)
    (cider-repl-display-in-current-window nil)
    ;; enable if you want help displayed at the top of the CIDER nREPL
    (cider-repl-display-help-banner nil)
    ;; disable if it makes emacs slow
    (cider-font-lock-dynamically t))
  #+END_SRC
